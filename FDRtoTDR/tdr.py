import numpy as np
import pandas as pd

S11 = np.array([0.30773296-0.006141103j, -0.42475632+0.3538512j, 0.81011328-0.094199496j, -0.651433408-0.489114144j, 0.276720032+0.40771936j, -0.346600608+0.480776736j, 0.735612032-0.080348144j, -0.2167428-0.754806016j, 0.007076258+0.15274144j, -0.565896832+0.46066976j, 0.662786816+0.438482464j, 0.400136448-0.571339392j, 0.049057844-0.419282208j, -0.811794688-0.008703372j, 0.021159398+0.831072128j, 0.693664448-0.072668016j, 0.451526656-0.52495264j, -0.559204288-0.57539104j, -0.603310464+0.426578592j, 0.20825312+0.445477376j, 0.640239104+0.034142628j, 0.152705616-0.672740608j, -0.59167296-0.32319408j, -0.511392+0.287633248j, 0.218108192+0.653273984j, 0.67817888-0.178050528j, -0.087189184-0.639705472j, -0.648452096-0.20471632j, -0.393500608+0.555219008j, 0.385260736+0.428342208j, 0.444793312-0.253936496j, -0.159669136-0.507637728j, -0.508262624+0.001042618j, -0.206045888+0.400936032j, 0.240198368+0.367310464j, 0.39284784-0.138716976j, -0.129050224-0.420575744j, -0.461940224+0.073514808j, -0.1453868+0.403556j, 0.19283552+0.301529184j, 0.293795168-0.029077406j, 0.028306662-0.268632672j, -0.296468224-0.159245424j, -0.34050944+0.290384128j, 0.150732864+0.507183264j, 0.54136672+0.071890872j, 0.157314096-0.486401024j, -0.517084352-0.16573336j, -0.306262272+0.531568064j, 0.360779808+0.543140608j, 0.586061888-0.103356768j, -0.024157306-0.550365056j, -0.585050944+0.021111804j, -0.104028608+0.639684992j, 0.579387584+0.348960352j, 0.560326592-0.360600544j, -0.119381888-0.58365184j, -0.50940864+0.068930112j, 0.058948392+0.611620608j, 0.579525376+0.1802532j, 0.366076736-0.375092544j, -0.229889984-0.352365664j, -0.31818144+0.210706768j, 0.186528+0.357553888j, 0.395170976-0.05107682j, 0.102844184-0.322391296j, -0.172818672-0.185919744j, -0.128029512+0.042411004j, 0.055849236+0.039545248j, 0.098452024-0.076728072j, 0.080521344-0.17045752j, -0.013918602-0.2799912j, -0.236312576-0.24177904j, -0.305207072+0.077200064j, 0.040835168+0.225824496j, 0.25295952-0.162314144j, -0.1210622-0.433716768j, -0.448952448-0.141674736j, -0.301795648+0.249902592j, 0.084280248+0.293648224j, 0.320821984-0.108561512j, -0.098479128-0.531333312j, -0.603268864-0.18764264j, -0.40321088+0.360122784j, 0.221697216+0.39018976j, 0.432795392-0.327848352j, -0.328283744-0.55827808j, -0.540378048+0.170419024j, 0.053024088+0.533621248j, 0.551289216+0.079174984j, 0.254306528-0.40202864j, -0.25842184-0.393728064j, -0.444399616+0.200181808j, 0.109103624+0.523243712j, 0.57733504+0.135012736j, 0.367740992-0.477639168j, -0.408959584-0.466580064j, -0.436650112+0.290487648j, 0.210864096+0.598440448j, 0.712999552+0.008633586j, 0.319293248-0.686298816j])

cable_vf = 0.66
speed_of_light = 299792458.0

npts = len(S11)
# M=2*(Npts-1);
M = 2 * (npts-1)
# % Npts=M-1;
# RangeTime=1/DeltaFreq;
deltafreq = 15049500 - 50000

rangetime = 1/deltafreq
# DeltaTime=RangeTime/(M-1);
deltatime = rangetime/(M-1)
# taxis=(0:DeltaTime:RangeTime);
taxis = np.linspace(0, rangetime, M)
daxis = speed_of_light/2.0*cable_vf*taxis
# % excitaci√≥n tipo impulso ficticio en el dominio temporal
# v1=zeros(1,M);
v1 = np.zeros(M)
# v1(1)=1;
v1[0] =1
# % su transformada
# f1=fft(v1);
f1 = np.fft.fft(v1)
# fftPasada por una ventana Hamming para eliminar sobreoscilaciones
# f1=f1.*fftshift(hamming1(M));
f1 = f1 * np.fft.fftshift(np.hamming(M))

# % Asumimos que la respuesta en frecuencia de nuestro sistema a frecuencias
# % negativas es el complejo conjugado de la que hemos medido a frecuencias
# % positivas

# respfreq=[f1(1:M/2).*S11(1:M/2) f1(M/2+1:M).*conj(fliplr(S11(2:M/2+1)))];
respfreq = np.concatenate((f1[0:int(M/2)]*S11[0:int(M/2)], f1[(int(M/2)):M]*np.conj(np.fliplr([S11[1:(int(M/2)+1)]])[0])))

# % Transformada inversa para pasar al dominio del tiempo

# v2=ifft(respfreq);
v2 = np.fft.ifft(respfreq)

# % Integramos para respuesta al escalon

# pp=cumsum(real(v2));
rho = np.real(v2).cumsum()

res = pd.DataFrame({
    'taxis': taxis,
    'daxis': daxis,
    'rho': rho
})

res.to_csv("tdr.txt", sep='\t', index=False)
    
